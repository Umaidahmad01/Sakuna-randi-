import os
import asyncio
from pyrogram import Client, filters
from pyrogram.enums import ParseMode
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from pyrogram.errors import FloodWait, UserIsBlocked, InputUserDeactivated

from bot import Bot
from config import *
from helper_func import *
from database.database import add_user, del_user, full_userbase, present_user

@Bot.on_message(filters.command('start') & filters.private & subscribed1 & subscribed2 & subscribed3)
async def start_command(client: Client, message: Message):
    id = message.from_user.id
    if not await present_user(id):
        try:
            await add_user(id)
        except:
            pass

    # Handle normal message flow
    text = message.text
    if len(text) > 7:
        try:
            base64_string = text.split(" ", 1)[1]
        except IndexError:
            return

        string = await decode(base64_string)
        argument = string.split("-")

        ids = []
        if len(argument) == 3:
            try:
                start = int(int(argument[1]) / abs(client.db_channel.id))
                end = int(int(argument[2]) / abs(client.db_channel.id))
                ids = range(start, end + 1) if start <= end else list(range(start, end - 1, -1))
            except Exception as e:
                print(f"Error decoding IDs: {e}")
                return

        elif len(argument) == 2:
            try:
                ids = [int(int(argument[1]) / abs(client.db_channel.id))]
            except Exception as e:
                print(f"Error decoding ID: {e}")
                return

        temp_msg = await message.reply("Please wait...")
        try:
            messages = await get_messages(client, ids)
        except Exception as e:
            await message.reply_text("Something went wrong!")
            print(f"Error getting messages: {e}")
            return
        finally:
            await temp_msg.delete()

        codeflix_msgs = []
        for msg in messages:
            caption = (CUSTOM_CAPTION.format(previouscaption="" if not msg.caption else msg.caption.html, 
                                             filename=msg.document.file_name) if bool(CUSTOM_CAPTION) and bool(msg.document)
                       else ("" if not msg.caption else msg.caption.html))

            reply_markup = msg.reply_markup if DISABLE_CHANNEL_BUTTON else None

            try:
                copied_msg = await msg.copy(chat_id=message.from_user.id, caption=caption, parse_mode=ParseMode.HTML, 
                                            reply_markup=reply_markup, protect_content=PROTECT_CONTENT)
                codeflix_msgs.append(copied_msg)
            except FloodWait as e:
                await asyncio.sleep(e.x)
                copied_msg = await msg.copy(chat_id=message.from_user.id, caption=caption, parse_mode=ParseMode.HTML, 
                                            reply_markup=reply_markup, protect_content=PROTECT_CONTENT)
                codeflix_msgs.append(copied_msg)
            except Exception as e:
                print(f"Failed to send message: {e}")
                pass

        if FILE_AUTO_DELETE > 0:
            notification_msg = await message.reply(
                f"<b>This file will be deleted in {get_exp_time(FILE_AUTO_DELETE)}. Please save or forward it to your saved messages before it gets deleted.</b>"
            )

            await asyncio.sleep(FILE_AUTO_DELETE)

            for snt_msg in codeflix_msgs:    
                if snt_msg:
                    try:    
                        await snt_msg.delete()  
                    except Exception as e:
                        print(f"Error deleting message {snt_msg.id}: {e}")

            try:
                reload_url = (
                    f"https://t.me/{client.username}?start={message.command[1]}"
                    if message.command and len(message.command) > 1
                    else None
                )
                keyboard = InlineKeyboardMarkup(
                    [[InlineKeyboardButton("É¢á´‡á´› Ò“ÉªÊŸá´‡ á´€É¢á´€ÉªÉ´!", url=reload_url),
                      InlineKeyboardButton("Close", callback_data = "close")]]
                ) if reload_url else None

                await notification_msg.edit(
                    "<b>Êá´á´œÊ€ á´ Éªá´…á´‡á´ / êœ°ÉªÊŸá´‡ Éªêœ± êœ±á´œá´„á´„á´‡êœ±êœ±êœ°á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… !!\n\ná´„ÊŸÉªá´„á´‹ Ê™á´‡ÊŸá´á´¡ Ê™á´œá´›á´›á´É´ á´›á´ É¢á´‡á´› Êá´á´œÊ€ á´…á´‡ÊŸá´‡á´›á´‡á´… á´ Éªá´…á´‡á´ / êœ°ÉªÊŸá´‡ ğŸ‘‡</b>",
                    reply_markup=keyboard
                )
            except Exception as e:
                print(f"Error updating notification with 'Get File Again' button: {e}")
    else:
        reply_markup = InlineKeyboardMarkup(
            [

    [
                    InlineKeyboardButton("ğ—”ğ—¯ğ—¼ğ˜‚ğ˜", callback_data = "about"),
                    InlineKeyboardButton('ğ—–ğ—µğ—®ğ—»ğ—»ğ—²ğ—¹ğ˜€', url='https://t.me/nova_flix')

    ]
            ]
        )
        await message.reply_photo(
            photo=START_PIC,
            caption=START_MSG.format(
                first=message.from_user.first_name,
                last=message.from_user.last_name,
                username=None if not message.from_user.username else '@' + message.from_user.username,
                mention=message.from_user.mention,
                id=message.from_user.id
            ),
            reply_markup=reply_markup#,
            #message_effect_id=5104841245755180586  # ğŸ”¥
        )
        return



# =====================================================================================##

WAIT_MSG = "<b>Working....</b>"

REPLY_ERROR = "<code>Use this command as a reply to any telegram message without any spaces.</code>"

# =====================================================================================##


@Bot.on_message(filters.command('start') & filters.private)
async def not_joined(client: Client, message: Message):
    user_id = message.from_user.id

    # Check subscription status
    sub1 = await is_subscribed1(None, client, message)
    sub2 = await is_subscribed2(None, client, message)
    sub3 = await is_subscribed3(None, client, message)

    buttons = []

    if sub1 and not sub2 and not sub3:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink2)]
        )
    elif sub2 and not sub1 and not sub3:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink)]
        )
    elif sub3 and not sub1 and not sub2:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink3)]
        )
    elif not sub1 and not sub2 and not sub3:
        buttons.append(
            [
                InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ", url=client.invitelink),
                InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink2),
                InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink3),
            ]
        )
    elif sub1 and sub2 and not sub3:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink3)]
        )
    elif sub1 and sub3 and not sub2:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink)]
        )
    elif sub2 and sub3 and not sub1:
        buttons.append(
            [InlineKeyboardButton(text="â€¢ á´Šá´ÉªÉ´ á´„Êœá´€É´É´á´‡ÊŸ â€¢", url=client.invitelink2)]
        )
    elif sub1 and sub2 and sub3:
        # All subscriptions are satisfied; no need to add buttons for joining.
        pass

    try:
        buttons.append(
            [
                InlineKeyboardButton(
                    text='â€¢ á´›Ê€Ê á´€É¢á´€ÉªÉ´ â€¢',
                    url=f"https://t.me/{client.username}?start={message.command[1]}"
                )
            ]
        )
    except IndexError:
        pass

    await message.reply_photo(
        photo=FORCE_PIC,
        text=FORCE_MSG.format(
            first=message.from_user.first_name,
            last=message.from_user.last_name,
            username=None if not message.from_user.username else '@' + message.from_user.username,
            mention=message.from_user.mention,
            id=message.from_user.id
        ),
        reply_markup=InlineKeyboardMarkup(buttons),
        quote=True,
        disable_web_page_preview=True,
        message_effect_id=5104841245755180586  # Add the effect ID here
    )


@Bot.on_message(filters.command('users') & filters.private & filters.user(ADMINS))
async def get_users(client: Bot, message: Message):
    msg = await client.send_message(chat_id=message.chat.id, text=WAIT_MSG)
    users = await full_userbase()
    await msg.edit(f"{len(users)} users are using this bot")


@Bot.on_message(filters.private & filters.command('broadcast') & filters.user(ADMINS))
async def send_text(client: Bot, message: Message):
    if message.reply_to_message:
        query = await full_userbase()
        broadcast_msg = message.reply_to_message
        total = 0
        successful = 0
        blocked = 0
        deleted = 0
        unsuccessful = 0

        pls_wait = await message.reply("<i>Ê™Ê€á´á´€á´…á´„á´€êœ±á´› á´˜Ê€á´á´„á´‡êœ±êœ±ÉªÉ´É¢....</i>")
        for chat_id in query:
            try:
                await broadcast_msg.copy(chat_id)
                successful += 1
            except FloodWait as e:
                await asyncio.sleep(e.x)
                await broadcast_msg.copy(chat_id)
                successful += 1
            except UserIsBlocked:
                await del_user(chat_id)
                blocked += 1
            except InputUserDeactivated:
                await del_user(chat_id)
                deleted += 1
            except:
                unsuccessful += 1
                pass
            total += 1

        status = f"""<b><u>Ê™Ê€á´á´€á´…á´„á´€êœ±á´›...</u>

Total Users: <code>{total}</code>
Successful: <code>{successful}</code>
Blocked Users: <code>{blocked}</code>
Deleted Accounts: <code>{deleted}</code>
Unsuccessful: <code>{unsuccessful}</code></b>"""

        return await pls_wait.edit(status)

    else:
        msg = await message.reply(REPLY_ERROR)
        await asyncio.sleep(8)
        await msg.delete()